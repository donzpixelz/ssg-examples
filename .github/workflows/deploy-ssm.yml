name: Deploy static app to EC2 via SSM (OIDC + Instance ID)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  DEFAULT_REMOTE_DIR: /var/www/ssg-examples
  ARTIFACT_PREFIX: ssg-examples/artifacts

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: ssg-examples-${{ github.run_id }}

      - name: Detect package manager
        id: pm
        shell: bash
        run: |
          if [ -f pnpm-lock.yaml ]; then echo "pm=pnpm" >> "$GITHUB_OUTPUT";
          elif [ -f yarn.lock ]; then echo "pm=yarn" >> "$GITHUB_OUTPUT";
          else echo "pm=npm" >> "$GITHUB_OUTPUT"; fi

      - name: Build (if package.json has a build script)
        id: build
        shell: bash
        run: |
          set -e
          if [ -f package.json ] && jq -e '.scripts.build' package.json >/dev/null 2>&1; then
            case "${{ steps.pm.outputs.pm }}" in
              pnpm) corepack enable pnpm >/dev/null 2>&1 || true; pnpm i --frozen-lockfile; pnpm build ;;
              yarn) yarn --frozen-lockfile; yarn build ;;
              npm)  npm ci; npm run build ;;
            esac
            echo "did_build=true" >> "$GITHUB_OUTPUT"
          else
            echo "did_build=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Choose site output folder (with root fallback)
        id: outdir
        shell: bash
        run: |
          set -e
          for d in dist build out public app site docs; do
            if [ -d "$d" ]; then echo "path=./$d" >> "$GITHUB_OUTPUT"; echo "Using $d"; exit 0; fi
          done
          if [ -f index.html ]; then
            echo "path=./" >> "$GITHUB_OUTPUT"
            echo "Using repo root (index.html found)"
          else
            echo "No output dir or root index.html. Create ./dist or ./public or add index.html in repo root." >&2
            exit 1
          fi

      - name: Package static site (tar.gz)
        id: pack
        shell: bash
        run: |
          set -e
          mkdir -p artifact
          OUT="${{ steps.outdir.outputs.path }}"
          if [ "$OUT" = "./" ]; then
            tar -czf artifact/site.tgz \
              --exclude-vcs \
              --exclude='./.github' \
              --exclude='./.git' \
              --exclude='./node_modules' \
              --exclude='./.*' \
              --exclude='./*.sh' \
              --exclude='./README*' \
              -C . .
          else
            tar -C "$OUT" -czf artifact/site.tgz .
          fi
          echo "path=artifact/site.tgz" >> "$GITHUB_OUTPUT"

      - name: Ensure artifacts bucket exists + upload artifact
        id: upload
        shell: bash
        run: |
          set -e
          ACCOUNT_ID="$(aws sts get-caller-identity --query Account --output text)"
          BUCKET="ssg-examples-artifacts-${ACCOUNT_ID}-${AWS_REGION}"
          KEY="${{ env.ARTIFACT_PREFIX }}/${{ github.sha }}.tgz"
          if ! aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            aws s3api create-bucket --bucket "$BUCKET" --region "$AWS_REGION" --create-bucket-configuration LocationConstraint="$AWS_REGION"
            aws s3api put-bucket-versioning --bucket "$BUCKET" --versioning-configuration Status=Enabled
            aws s3api put-public-access-block --bucket "$BUCKET" --public-access-block-configuration BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true
          fi
          aws s3 cp "${{ steps.pack.outputs.path }}" "s3://$BUCKET/$KEY"
          echo "bucket=$BUCKET" >> "$GITHUB_OUTPUT"
          echo "key=$KEY" >> "$GITHUB_OUTPUT"

      - name: Presign artifact
      # shorter id for clarity
        id: presign
        shell: bash
        run: |
          URL="$(aws s3 presign "s3://${{ steps.upload.outputs.bucket }}/${{ steps.upload.outputs.key }}" --expires-in 3600)"
          echo "url=${URL}" >> "$GITHUB_OUTPUT"

      - name: Resolve Instance ID + IP
        id: inst
        shell: bash
        run: |
          test -n "${{ secrets.EC2_INSTANCE_ID }}" || { echo "Missing EC2_INSTANCE_ID secret"; exit 1; }
          IID="${{ secrets.EC2_INSTANCE_ID }}"
          IP="$(aws ec2 describe-instances --region "${AWS_REGION}" --instance-ids "$IID" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text || true)"
          echo "iid=${IID}" >> "$GITHUB_OUTPUT"
          echo "ip=${IP}"  >> "$GITHUB_OUTPUT"
          echo "Deploying to InstanceId: $IID (IP: $IP)"

      - name: Deploy via SSM (diagnostic, no SSH)
        id: ssm
        shell: bash
        run: |
          set -e
          IID="${{ steps.inst.outputs.iid }}"
          PRESIGNED="${{ steps.presign.outputs.url }}"
          REMOTE_DIR="${{ env.DEFAULT_REMOTE_DIR }}"

          # Build a verbose script that logs every step on the instance
          cat > run.sh <<'EOS'
          set -Eeuo pipefail
          LOG="/tmp/ssg-deploy.log"
          exec > >(tee -a "$LOG") 2>&1
          echo "=== ssg-examples SSM deploy ==="
          date -u

          PRESIGNED="__PRESIGNED__"
          REMOTE_DIR="__REMOTE_DIR__"

          echo "[1/9] Ensure base tools"
          if ! command -v curl >/dev/null 2>&1; then
            if command -v yum >/dev/null 2>&1; then sudo yum -y install curl >/dev/null; fi
            if command -v dnf >/dev/null 2>&1; then sudo dnf -y install curl >/dev/null; fi
            if command -v apt-get >/dev/null 2>&1; then sudo apt-get update -y >/dev/null && sudo apt-get install -y curl >/dev/null; fi
          fi
          if ! command -v tar >/dev/null 2>&1; then
            if command -v yum >/dev/null 2>&1; then sudo yum -y install tar >/dev/null; fi
            if command -v dnf >/dev/null 2>&1; then sudo dnf -y install tar >/dev/null; fi
            if command -v apt-get >/dev/null 2>&1; then sudo apt-get update -y >/dev/null && sudo apt-get install -y tar >/dev/null; fi
          fi
          if ! command -v rsync >/dev/null 2>&1; then
            if command -v yum >/dev/null 2>&1; then sudo yum -y install rsync >/dev/null || true; fi
            if command -v dnf >/dev/null 2>&1; then sudo dnf -y install rsync >/dev/null || true; fi
            if command -v apt-get >/dev/null 2>&1; then sudo apt-get update -y >/dev/null && sudo apt-get install -y rsync >/dev/null || true; fi
          fi

          echo "[2/9] Download artifact"
          sudo mkdir -p "$REMOTE_DIR"
          TMP="/tmp/site.tgz"
          echo "Downloading: $PRESIGNED"
          curl -fsSL "$PRESIGNED" -o "$TMP"
          echo "Download size: $(stat -c%s "$TMP" 2>/dev/null || stat -f%z "$TMP" 2>/dev/null) bytes"

          echo "[3/9] Validate archive"
          tar -tzf "$TMP" >/dev/null

          echo "[4/9] Unpack to staging"
          TMPDIR="$(mktemp -d)"
          tar -xzf "$TMP" -C "$TMPDIR"
          echo "Staged files:"
          (cd "$TMPDIR" && find . -maxdepth 2 -type f | head -n 50)

          echo "[5/9] Detect nginx docroot (if nginx installed)"
          DOCROOT=""
          if command -v nginx >/dev/null 2>&1; then
            DOCROOT="$(sudo nginx -T 2>/dev/null | awk '/^[[:space:]]*root[[:space:]]+/ && $0 !~ /#/ {gsub(/;$/,"",$2); print $2; exit}')"
          fi
          [ -n "$DOCROOT" ] || DOCROOT="/var/www/html"
          echo "Using REMOTE_DIR=$REMOTE_DIR  DOCROOT=$DOCROOT"
          sudo mkdir -p "$DOCROOT"

          echo "[6/9] Sync to REMOTE_DIR"
          if command -v rsync >/dev/null 2>&1; then
            sudo rsync -a --delete "$TMPDIR"/ "$REMOTE_DIR"/
          else
            sudo rm -rf "$REMOTE_DIR"/*; sudo cp -a "$TMPDIR"/. "$REMOTE_DIR"/
          fi

          echo "[7/9] Sync to DOCROOT (if different)"
          if [ "$DOCROOT" != "$REMOTE_DIR" ]; then
            if command -v rsync >/dev/null 2>&1; then
              sudo rsync -a --delete "$TMPDIR"/ "$DOCROOT"/
            else
              sudo rm -rf "$DOCROOT"/*; sudo cp -a "$TMPDIR"/. "$DOCROOT"/
            fi
          fi

          echo "[8/9] Ownership + reload nginx (best effort)"
          sudo chown -R ec2-user:ec2-user "$REMOTE_DIR" || true
          if id nginx >/dev/null 2>&1; then sudo chown -R nginx:nginx "$DOCROOT" || true; fi
          sudo systemctl reload nginx 2>/dev/null || true

          echo "[9/9] Cleanup"
          sudo rm -rf "$TMPDIR" "$TMP"
          echo "Done."
          EOS

          safe_url=$(printf '%s' "$PRESIGNED" | sed -e 's/[\/&]/\\&/g')
          sed -i "s|__PRESIGNED__|$safe_url|g" run.sh
          sed -i "s|__REMOTE_DIR__|$REMOTE_DIR|g" run.sh
          B64=$(base64 -w 0 < run.sh)

          cat > /tmp/ssm.json <<JSON
          {
            "DocumentName": "AWS-RunShellScript",
            "InstanceIds": ["$IID"],
            "Parameters": {
              "commands": ["echo $B64 | base64 -d | sudo bash -s"],
              "executionTimeout": ["900"],
              "workingDirectory": ["/home/ec2-user"]
            },
            "Comment": "ssg-examples deploy $GITHUB_SHA"
          }
          JSON

          CMD_ID=$(aws ssm send-command --cli-input-json file:///tmp/ssm.json --query "Command.CommandId" --output text)
          echo "SSM CommandId: $CMD_ID"

          # Poll and dump full logs on failure
          for i in $(seq 1 40); do
            STATUS="$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$IID" --query Status --output text || true)"
            echo "SSM status: $STATUS"
            case "$STATUS" in
              Success) exit 0 ;;
              Failed|Cancelled|TimedOut)
                echo "=== STDOUT ==="
                aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$IID" --query StandardOutputContent --output text || true
                echo "=== STDERR ==="
                aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$IID" --query StandardErrorContent --output text || true
                exit 1 ;;
              *) sleep 5 ;;
            esac
          done
          echo "SSM command did not finish in time"; exit 1
