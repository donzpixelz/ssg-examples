name: deploy-site-ssm

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'app/**'
      - 'nginx/**'
      - 'run.sh'
      - '.github/workflows/deploy-site-ssm.yml'

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::953331331353:role/GitHubOIDC-ssg-examples
          aws-region: us-east-2

      - name: Who am I?
        run: aws sts get-caller-identity

      - name: Resolve bucket
        run: |
          set -euo pipefail
          SECRET_VAL="${{ secrets.DEPLOY_S3_BUCKET }}"
          echo "AWS_REGION=us-east-2" >> "$GITHUB_ENV"
          if [ -n "$SECRET_VAL" ]; then
            echo "BUCKET=$SECRET_VAL" >> "$GITHUB_ENV"
          else
            echo "BUCKET=ssg-examples-deploy-953331331353-us-east-2" >> "$GITHUB_ENV"
          fi
          echo "Using bucket: ${SECRET_VAL:-ssg-examples-deploy-953331331353-us-east-2}"

      - name: Ensure bucket exists (idempotent)
        run: |
          set -euo pipefail
          if aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            echo "Bucket exists: $BUCKET"
          else
            echo "Creating bucket: $BUCKET in $AWS_REGION"
            if [ "$AWS_REGION" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$BUCKET" || true
            else
              aws s3api create-bucket --bucket "$BUCKET" \
                --create-bucket-configuration LocationConstraint="$AWS_REGION" || true
            fi
            aws s3api head-bucket --bucket "$BUCKET" >/dev/null 2>&1 || { echo "❌ Bucket ensure failed"; exit 1; }
            aws s3api put-bucket-versioning --bucket "$BUCKET" --versioning-configuration Status=Enabled || true
          fi

      - name: Package site (app + optional nginx/)
        run: |
          set -euo pipefail
          test -f app/index.html || { echo "❌ app/index.html missing"; exit 2; }
          if [ -d nginx ]; then
            tar -czf site.tgz app nginx
          else
            tar -czf site.tgz app
          fi
          ls -l site.tgz

      - name: Upload to S3 and presign
        run: |
          set -euo pipefail
          KEY_PREFIX="examples/artifacts/${GITHUB_SHA}"
          aws s3 cp site.tgz "s3://${BUCKET}/${KEY_PREFIX}/site.tgz" --region "$AWS_REGION" --acl bucket-owner-full-control
          echo "APP_URL=$(aws s3 presign s3://${BUCKET}/${KEY_PREFIX}/site.tgz --region $AWS_REGION --expires-in 3600)" >> $GITHUB_ENV
          echo "APP_URL presigned."

      - name: Resolve SSM instance IDs (secret or Name tag)
        id: ids
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail
          NAME_TAG="ssg-examples"
          pat='^(i-[a-f0-9]{8}|i-[a-f0-9]{17}|mi-[a-z0-9]{17})$'
          ids_secret='${{ secrets.SSM_INSTANCE_ID }}'
          ids=""
          if [ -n "$ids_secret" ] && [[ "$ids_secret" =~ $pat ]]; then
            ids="$ids_secret"
            echo "Using SSM_INSTANCE_ID secret: $ids"
          else
            echo "Secret missing/invalid. Querying by Name tag: $NAME_TAG"
            ids=$(aws ec2 describe-instances --region "$AWS_REGION" \
                  --filters "Name=tag:Name,Values=$NAME_TAG" "Name=instance-state-name,Values=running" \
                  --query 'Reservations[].Instances[].InstanceId' --output text | tr '\t' ' ' | xargs || true)
          fi
          [ -n "$ids" ] || { echo "❌ No instance IDs found"; exit 12; }
          echo "IDS=$ids" >> "$GITHUB_OUTPUT"

      - name: SSM dispatch (inline deploy) — with quoted URL — and wait
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          IDS: ${{ steps.ids.outputs.IDS }}
          APP_URL: ${{ env.APP_URL }}
        run: |
          set -euo pipefail
          # ensure jq
          command -v jq >/dev/null 2>&1 || { sudo apt-get update -y && sudo apt-get install -y jq; }

          # Convert space-separated IDs -> JSON array
          json_ids=$(printf '%s\n' $IDS | jq -R . | jq -s .)

          # Build commands with the URL safely quoted via jq @sh (shell-escaped)
          jq -n --argjson arr "$json_ids" --arg app "$APP_URL" '{
            DocumentName: "AWS-RunShellScript",
            InstanceIds: $arr,
            Parameters: { commands: [
              "set -euo pipefail",
              "trap \"\" PIPE",
              "WORK=$(mktemp -d /tmp/site_deploy.XXXXXX)",
              "ARCH=$WORK/site.tgz",
              "STAGE=$WORK/stage",
              "mkdir -p $STAGE",
              "echo [1/6] download",
              ("APP_URL=" + ($app|@sh)),
              "curl -fsSL --retry 3 --retry-delay 2 -o $ARCH \"$APP_URL\"",
              "echo [2/6] validate",
              "tar -tzf $ARCH >/dev/null 2>&1",
              "echo [3/6] unpack",
              "tar -xzf $ARCH -C $STAGE",
              "DOCROOT=/usr/share/nginx/html",
              "echo [4/6] ensure nginx",
              "if ! command -v nginx >/dev/null 2>&1; then if command -v dnf >/dev/null 2>&1; then dnf -y install nginx; else yum -y install nginx; fi; fi",
              "mkdir -p /etc/nginx/conf.d $DOCROOT",
              "echo [5/6] deploy files",
              "if [ -d $STAGE/app ]; then SRC=$STAGE/app; else SRC=$STAGE; fi",
              "if command -v rsync >/dev/null 2>&1; then rsync -a --delete $SRC/ $DOCROOT/; else find $DOCROOT -mindepth 1 -maxdepth 1 -exec rm -rf {} + 2>/dev/null || true; cp -a $SRC/. $DOCROOT/; fi",
              "chmod -R a+rX $DOCROOT",
              "echo [6/6] restart nginx",
              "if command -v systemctl >/dev/null 2>&1; then systemctl daemon-reload || true; systemctl enable nginx || true; systemctl restart nginx; else service nginx restart || service nginx start; fi",
              "curl -fsS --max-time 8 http://127.0.0.1/ >/dev/null",
              "echo DONE_OK"
            ]}
          }' > payload.json

          echo "Dispatching to: $IDS"
          send_out=$(aws ssm send-command --region "$AWS_REGION" --cli-input-json file://payload.json)
          cmd_id=$(echo "$send_out" | jq -r '.Command.CommandId')

          # Wait & stream logs
          fail=0
          for iid in $IDS; do
            echo "Waiting for $iid (CommandId: $cmd_id)..."
            for i in $(seq 1 60); do
              sleep 5
              inv=$(aws ssm get-command-invocation --region "$AWS_REGION" --command-id "$cmd_id" --instance-id "$iid" || true)
              status=$(echo "$inv" | jq -r '.Status // "Unknown"')
              if [ "$status" = "Success" ] || [ "$status" = "Failed" ] || [ "$status" = "TimedOut" ] || [ "$status" = "Cancelled" ]; then
                echo "---- $iid :: Status: $status ----"
                echo "STDOUT:"
                echo "$inv" | jq -r '.StandardOutputContent // ""'
                echo "STDERR:"
                echo "$inv" | jq -r '.StandardErrorContent // ""'
                [ "$status" = "Success" ] || fail=1
                break
              fi
              [ $i -lt 60 ] || { echo "Timed out waiting for $iid"; fail=1; }
            done
          done
          [ $fail -eq 0 ] || { echo "❌ SSM reported failure."; exit 1; }
          echo "✅ SSM completed successfully."
